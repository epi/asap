// asapinfo.ci - module parser
//
// Copyright (C) 2010-2023  Piotr Fusik
//
// This file is part of ASAP (Another Slight Atari Player),
// see http://asap.sourceforge.net
//
// ASAP is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published
// by the Free Software Foundation; either version 2 of the License,
// or (at your option) any later version.
//
// ASAP is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with ASAP; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

enum ASAPModuleType
{
	SapB,
	SapC,
	SapD,
	SapS,
	Cmc,
	Cm3,
	Cmr,
	Cms,
	Dlt,
	Mpt,
	Rmt,
	Tmc,
	Tm2,
	Fc
#if EXPERIMENTAL_XEX
	// actually it works, but without VBLKI it's practically useless
	, Xex
#endif
}

class DurationParser
{
	string Source;
	int Position;
	int Length;

	int ParseDigit!(int max)
		throws
	{
		if (Position >= Length)
			throw "Invalid duration";
		int digit = Source[Position++] - '0';
		if (digit < 0 || digit > max)
			throw "Invalid duration";
		return digit;
	}

	internal int Parse!(string s)
		throws
	{
		Source = s;
		Position = 0;
		Length = s.Length;
		int result = ParseDigit(9);
		int digit;
		if (Position < Length) {
			digit = s[Position] - '0';
			if (digit >= 0 && digit <= 9) {
				Position++;
				result = result * 10 + digit;
			}
			if (Position < Length && s[Position] == ':') {
				Position++;
				digit = ParseDigit(5);
				result = result * 60 + digit * 10;
				digit = ParseDigit(9);
				result += digit;
			}
		}
		result *= 1000;
		if (Position >= Length)
			return result;
		if (s[Position++] != '.')
			throw "Invalid duration";
		digit = ParseDigit(9);
		result += digit * 100;
		if (Position >= Length)
			return result;
		digit = ParseDigit(9);
		result += digit * 10;
		if (Position >= Length)
			return result;
		digit = ParseDigit(9);
		result += digit;
		return result;
	}
}

/// Information about a music file.
public class ASAPInfo
{
	/// ASAP version - major part.
	public const int VersionMajor = 5;
	/// ASAP version - minor part.
	public const int VersionMinor = 3;
	/// ASAP version - micro part.
	public const int VersionMicro = 0;
	/// ASAP version as a string.
	public const string Version = $"{VersionMajor}.{VersionMinor}.{VersionMicro}";

	/// Years ASAP was created in.
	public const string Years = "2005-2023";

	/// Short credits for ASAP.
	public const string Credits =
		$"Another Slight Atari Player (C) {Years} Piotr Fusik\n" +
		"CMC, MPT, TMC, TM2 players (C) 1994-2005 Marcin Lewandowski\n" +
		"RMT player (C) 2002-2005 Radek Sterba\n" +
		"DLT player (C) 2009 Marek Konopka\n" +
		"CMS player (C) 1999 David Spilka\n" +
		"FC player (C) 2011 Jerzy Kut\n";

	/// Short license notice.
	/// Display after the credits.
	public const string Copyright =
		"This program is free software; you can redistribute it and/or modify it " +
		"under the terms of the GNU General Public License as published " +
		"by the Free Software Foundation; either version 2 of the License, " +
		"or (at your option) any later version.";

	/// Maximum length of a supported input file.
	/// You may assume that files longer than this are not supported by ASAP.
	public const int MaxModuleLength = 65000;

	/// Maximum length of text metadata.
	public const int MaxTextLength = 127;

	/// Maximum number of songs in a file.
	public const int MaxSongs = 32;

#if !OPENCL
	string() Filename;
	string() Author;
	string() Title;
	string() Date;
#endif
	int Channels;
	int Songs;
	int DefaultSong;
	int[MaxSongs] Durations;
	bool[MaxSongs] Loops;
	bool Ntsc;
	internal ASAPModuleType Type;
	int Fastplay;
	int Music;
	int Init;
	internal int Player;
	int CovoxAddr;
	internal int HeaderLen;
	internal byte[MaxSongs] SongPos;

	public ASAPInfo()
	{
	}

	static bool IsValidChar(int c) => c >= ' ' && c <= '|' && c != '`' && c != '{';

	static void CheckValidChar(int c)
		throws
	{
		if (!IsValidChar(c))
			throw "Invalid character";
	}

	internal static int GetWord(byte[] array, int i) => array[i] + (array[i + 1] << 8);

	void ParseModule!(byte[] module, int moduleLen)
		throws
	{
		if ((module[0] != 0xff || module[1] != 0xff)
		 && (module[0] != 0 || module[1] != 0)) // some CMC and clones start with zeros
			throw "Invalid two leading bytes of the module";
		Music = GetWord(module, 2);
		int musicLastByte = GetWord(module, 4);
		if (Music <= 0xd7ff && musicLastByte >= 0xd000)
			throw "Module address conflicts with hardware registers";
		int blockLen = musicLastByte + 1 - Music;
		if (6 + blockLen != moduleLen) {
			if (Type != ASAPModuleType.Rmt || 11 + blockLen > moduleLen)
				throw "Module length doesn't match headers";
			// allow optional info for Raster Music Tracker
			int infoAddr = GetWord(module, 6 + blockLen);
			if (infoAddr != Music + blockLen)
				throw "Invalid address of RMT info";
			int infoLen = GetWord(module, 8 + blockLen) + 1 - infoAddr;
			if (10 + blockLen + infoLen != moduleLen)
				throw "Invalid RMT info block";
		}
	}

	void AddSong!(int playerCalls)
	{
		long scanlines = playerCalls * Fastplay;
		Durations[Songs++] = scanlines * (114000 / 3) / (1773447 / 3);
	}

	// TODO: enum + 0
	const int SeenThisCall = 1;
	const int SeenBefore = 2;
	const int SeenRepeat = 3;

	void ParseCmcSong!(byte[] module, int pos)
	{
		int tempo = module[0x19];
		int playerCalls = 0;
		int repStartPos = 0;
		int repEndPos = 0;
		int repTimes = 0;
		byte[0x55] seen = 0;
		while (pos >= 0 && pos < 0x55) {
			if (pos == repEndPos && repTimes > 0) {
				for (int i = 0; i < 0x55; i++)
					if (seen[i] == SeenThisCall || seen[i] == SeenRepeat)
						seen[i] = 0;
				repTimes--;
				pos = repStartPos;
			}
			if (seen[pos] != 0) {
				if (seen[pos] != SeenThisCall)
					Loops[Songs] = true;
				break;
			}
			seen[pos] = SeenThisCall;
			int p1 = module[0x206 + pos];
			int p2 = module[0x25b + pos];
			int p3 = module[0x2b0 + pos];
			if (p1 == 0xfe || p2 == 0xfe || p3 == 0xfe) {
				pos++;
				continue;
			}
			p1 |= Type == ASAPModuleType.Cms ? 7 : 0xf;
			switch (p1) {
			case 0x87: // CMS VOLUME
			case 0xa7: // CMS MODE
				pos++;
				break;
			case 0x8f: // STOP
				pos = -1;
				break;
			case 0x97: // CMS PAUSE
				if (p2 < 128) {
					playerCalls += p2;
					if (p3 < 128)
						playerCalls += p3 * 50;
				}
				pos++;
				break;
			case 0x9f: // JUMP
				pos = p2;
				break;
			case 0xaf: // UP
				pos -= p2;
				break;
			case 0xbf: // DOWN
				pos += p2;
				break;
			case 0xcf: // TEMPO
				if (p2 < 128) {
					tempo = p2;
					pos++;
				}
				else
					pos = -1;
				break;
			case 0xdf: // REPLAY
				pos++;
				repStartPos = pos;
				repEndPos = pos + p2;
				repTimes = p3 - 1;
				break;
			case 0xef: // BREAK
				Loops[Songs] = true;
				pos = -1;
				break;
			default:
				p2 = repTimes > 0 ? SeenRepeat : SeenBefore;
				for (p1 = 0; p1 < 0x55; p1++)
					if (seen[p1] == SeenThisCall)
						seen[p1] = p2;
				playerCalls += tempo * (Type == ASAPModuleType.Cm3 ? 48 : 64);
				pos++;
				break;
			}
		}
		AddSong(playerCalls);
	}

	const int CmrBassTableOffset = 0x70f;

	void ParseCmc!(byte[] module, int moduleLen, ASAPModuleType type)
		throws
	{
		if (moduleLen < 0x306)
			throw "Module too short";
		Type = type;
		ParseModule(module, moduleLen);
		int lastPos = 0x54;
		while (--lastPos >= 0) {
			if (module[0x206 + lastPos] < 0xb0
			 || module[0x25b + lastPos] < 0x40
			 || module[0x2b0 + lastPos] < 0x40)
				break;
			if (Channels == 2) {
				if (module[0x306 + lastPos] < 0xb0
				 || module[0x35b + lastPos] < 0x40
				 || module[0x3b0 + lastPos] < 0x40)
					break;
			}
		}
		Songs = 0;
		ParseCmcSong(module, 0);
		for (int pos = 0; pos < lastPos && Songs < MaxSongs; pos++)
			if (module[0x206 + pos] == 0x8f || module[0x206 + pos] == 0xef)
				ParseCmcSong(module, pos + 1);
	}

	static bool IsDltTrackEmpty(byte[] module, int pos)
	{
		return module[0x2006 + pos] >= 0x43
			&& module[0x2106 + pos] >= 0x40
			&& module[0x2206 + pos] >= 0x40
			&& module[0x2306 + pos] >= 0x40;
	}

	static bool IsDltPatternEnd(byte[] module, int pos, int i)
	{
		for (int ch = 0; ch < 4; ch++) {
			int pattern = module[0x2006 + (ch << 8) + pos];
			if (pattern < 64) {
				int offset = 6 + (pattern << 7) + (i << 1);
				if ((module[offset] & 0x80) == 0 && (module[offset + 1] & 0x80) != 0)
					return true;
			}
		}
		return false;
	}

	void ParseDltSong!(byte[] module, bool[]! seen, int pos)
	{
		while (pos < 128 && !seen[pos] && IsDltTrackEmpty(module, pos))
			seen[pos++] = true;
		SongPos[Songs] = pos;
		int playerCalls = 0;
		bool loop = false;
		int tempo = 6;
		while (pos < 128) {
			if (seen[pos]) {
				loop = true;
				break;
			}
			seen[pos] = true;
			int p1 = module[0x2006 + pos];
			if (p1 == 0x40 || IsDltTrackEmpty(module, pos))
				break;
			if (p1 == 0x41)
				pos = module[0x2086 + pos];
			else if (p1 == 0x42)
				tempo = module[0x2086 + pos++];
			else {
				for (int i = 0; i < 64 && !IsDltPatternEnd(module, pos, i); i++)
					playerCalls += tempo;
				pos++;
			}
		}
		if (playerCalls > 0) {
			Loops[Songs] = loop;
			AddSong(playerCalls);
		}
	}

	void ParseDlt!(byte[] module, int moduleLen)
		throws
	{
		if (moduleLen != 0x2c06 && moduleLen != 0x2c07)
			throw "Invalid module length";
		Type = ASAPModuleType.Dlt;
		ParseModule(module, moduleLen);
		if (Music != 0x2000)
			throw "Unsupported module address";
		bool[128] seen = false;
		Songs = 0;
		for (int pos = 0; pos < 128 && Songs < MaxSongs; pos++) {
			if (!seen[pos])
				ParseDltSong(module, seen, pos);
		}
		if (Songs == 0)
			throw "No songs found";
	}

	void ParseMptSong!(byte[] module, bool[]! globalSeen, int songLen, int pos)
	{
		int addrToOffset = GetWord(module, 2) - 6;
		int tempo = module[0x1cf];
		int playerCalls = 0;
		byte[256] seen = 0;
		int[4] patternOffset;
		int[4] blankRows = 0;
		int[4] blankRowsCounter;
		while (pos < songLen) {
			if (seen[pos] != 0) {
				if (seen[pos] != SeenThisCall)
					Loops[Songs] = true;
				break;
			}
			seen[pos] = SeenThisCall;
			globalSeen[pos] = true;
			int i = module[0x1d0 + pos * 2];
			if (i == 0xff) {
				pos = module[0x1d1 + pos * 2];
				continue;
			}
			int ch;
			for (ch = 3; ch >= 0; ch--) {
				i = module[0x1c6 + ch] + (module[0x1ca + ch] << 8) - addrToOffset;
				i = module[i + pos * 2];
				if (i >= 0x40)
					break;
				i <<= 1;
				i = GetWord(module, 0x46 + i);
				patternOffset[ch] = i == 0 ? 0 : i - addrToOffset;
				blankRowsCounter[ch] = 0;
			}
			if (ch >= 0)
				break;
			for (i = 0; i < songLen; i++)
				if (seen[i] == SeenThisCall)
					seen[i] = SeenBefore;
			for (int patternRows = module[0x1ce]; --patternRows >= 0; ) {
				for (ch = 3; ch >= 0; ch--) {
					if (patternOffset[ch] == 0)
						continue;
					if (--blankRowsCounter[ch] >= 0)
						continue;
					for (;;) {
						i = module[patternOffset[ch]++];
						if (i < 0x40 || i == 0xfe)
							break;
						if (i < 0x80)
							continue;
						if (i < 0xc0) {
							blankRows[ch] = i - 0x80;
							continue;
						}
						if (i < 0xd0)
							continue;
						if (i < 0xe0) {
							tempo = i - 0xcf;
							continue;
						}
						patternRows = 0;
					}
					blankRowsCounter[ch] = blankRows[ch];
				}
				playerCalls += tempo;
			}
			pos++;
		}
		if (playerCalls > 0)
			AddSong(playerCalls);
	}

	void ParseMpt!(byte[] module, int moduleLen)
		throws
	{
		if (moduleLen < 0x1d0)
			throw "Module too short";
		Type = ASAPModuleType.Mpt;
		ParseModule(module, moduleLen);
		int track0Addr = GetWord(module, 2) + 0x1ca;
		if (module[0x1c6] + (module[0x1ca] << 8) != track0Addr)
			throw "Invalid address of the first track";
		// Calculate the length of the first track. Address of the second track minus
		// address of the first track equals the length of the first track in bytes.
		// Divide by two to get number of track positions.
		int songLen = (module[0x1c7] + (module[0x1cb] << 8) - track0Addr) >> 1;
		if (songLen > 0xfe)
			throw "Song too long";
		// `globalSeen[i] == true` if the track position `i` has been processed
		bool[256] globalSeen = false;
		Songs = 0;
		for (int pos = 0; pos < songLen && Songs < MaxSongs; pos++) {
			if (!globalSeen[pos]) {
				SongPos[Songs] = pos;
				ParseMptSong(module, globalSeen, songLen, pos);
			}
		}
		if (Songs == 0)
			throw "No songs found";
	}

	static int GetRmtInstrumentFrames(byte[] module, int instrument, int volume, int volumeFrame, bool onExtraPokey)
	{
		int addrToOffset = GetWord(module, 2) - 6;
		instrument = GetWord(module, 0xe) - addrToOffset + (instrument << 1);
		if (module[instrument + 1] == 0)
			return 0;
		instrument = GetWord(module, instrument) - addrToOffset;
		int perFrame = module[0xc];
		int playerCall = volumeFrame * perFrame;
		int playerCalls = playerCall;
		int index = module[instrument] + 1 + playerCall * 3;
		int indexEnd = module[instrument + 2] + 3;
		int indexLoop = module[instrument + 3];
		if (indexLoop >= indexEnd)
			return 0; // error
		int volumeSlideDepth = module[instrument + 6];
		int volumeMin = module[instrument + 7];
		const byte[] rmtVolumeSilent = { 16, 8, 4, 3, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1 };
		if (index >= indexEnd)
			index = (index - indexEnd) % (indexEnd - indexLoop) + indexLoop;
		else {
			do {
				int vol = module[instrument + index];
				if (onExtraPokey)
					vol >>= 4;
				if ((vol & 0xf) >= rmtVolumeSilent[volume])
					playerCalls = playerCall + 1;
				playerCall++;
				index += 3;
			} while (index < indexEnd);
		}
		if (volumeSlideDepth == 0)
			return playerCalls / perFrame;
		int volumeSlide = 128;
		bool silentLoop = false;
		for (;;) {
			if (index >= indexEnd) {
				if (silentLoop)
					break;
				silentLoop = true;
				index = indexLoop;
			}
			int vol = module[instrument + index];
			if (onExtraPokey)
				vol >>= 4;
			if ((vol & 0xf) >= rmtVolumeSilent[volume]) {
				playerCalls = playerCall + 1;
				silentLoop = false;
			}
			playerCall++;
			index += 3;
			volumeSlide -= volumeSlideDepth;
			if (volumeSlide < 0) {
				volumeSlide += 256;
				if (--volume <= volumeMin)
					break;
			}
		}
		return playerCalls / perFrame;
	}

	void ParseRmtSong!(byte[] module, bool[]! globalSeen, int songLen, int posShift, int pos)
	{
		int addrToOffset = GetWord(module, 2) - 6;
		int tempo = module[0xb];
		int frames = 0;
		int songOffset = GetWord(module, 0x14) - addrToOffset;
		int patternLoOffset = GetWord(module, 0x10) - addrToOffset;
		int patternHiOffset = GetWord(module, 0x12) - addrToOffset;
		byte[256] seen = 0;
		int[8] patternBegin;
		int[8] patternOffset;
		int[8] blankRows;
		int[8] instrumentNo = 0;
		int[8] instrumentFrame = 0;
		int[8] volumeValue = 0;
		int[8] volumeFrame = 0;
		while (pos < songLen) {
			if (seen[pos] != 0) {
				if (seen[pos] != SeenThisCall)
					Loops[Songs] = true;
				break;
			}
			seen[pos] = SeenThisCall;
			globalSeen[pos] = true;
			if (module[songOffset + (pos << posShift)] == 0xfe) {
				pos = module[songOffset + (pos << posShift) + 1];
				continue;
			}
			for (int ch = 0; ch < 1 << posShift; ch++) {
				int p = module[songOffset + (pos << posShift) + ch];
				if (p == 0xff)
					blankRows[ch] = 256;
				else {
					patternOffset[ch] = patternBegin[ch] = module[patternLoOffset + p]
						+ (module[patternHiOffset + p] << 8) - addrToOffset;
					if (patternOffset[ch] < 0)
						return; // badly ripped alien.rmt
					blankRows[ch] = 0;
				}
			}
			for (int i = 0; i < songLen; i++)
				if (seen[i] == SeenThisCall)
					seen[i] = SeenBefore;
			for (int patternRows = module[0xa]; --patternRows >= 0; ) {
				for (int ch = 0; ch < 1 << posShift; ch++) {
					if (--blankRows[ch] > 0)
						continue;
					for (;;) {
						int i = module[patternOffset[ch]++];
						if ((i & 0x3f) < 62) {
							i += module[patternOffset[ch]++] << 8;
							if ((i & 0x3f) != 61) {
								instrumentNo[ch] = i >> 10;
								instrumentFrame[ch] = frames;
							}
							volumeValue[ch] = (i >> 6) & 0xf;
							volumeFrame[ch] = frames;
							break;
						}
						if (i == 62) {
							blankRows[ch] = module[patternOffset[ch]++];
							break;
						}
						if ((i & 0x3f) == 62) {
							blankRows[ch] = i >> 6;
							break;
						}
						if ((i & 0xbf) == 63) {
							tempo = module[patternOffset[ch]++];
							continue;
						}
						if (i == 0xbf) {
							patternOffset[ch] = patternBegin[ch] + module[patternOffset[ch]];
							continue;
						}
						// assert(i == 0xff);
						patternRows = -1;
						break;
					}
					if (patternRows < 0)
						break;
				}
				if (patternRows >= 0)
					frames += tempo;
			}
			pos++;
		}
		int instrumentFrames = 0;
		for (int ch = 0; ch < 1 << posShift; ch++) {
			int frame = instrumentFrame[ch];
			frame += GetRmtInstrumentFrames(module, instrumentNo[ch], volumeValue[ch], volumeFrame[ch] - frame, ch >= 4);
			if (instrumentFrames < frame)
				instrumentFrames = frame;
		}
		if (frames > instrumentFrames) {
			if (frames - instrumentFrames > 100)
				Loops[Songs] = false;
			frames = instrumentFrames;
		}
		if (frames > 0)
			AddSong(frames);
	}

	static bool ValidateRmt(byte[] module, int moduleLen)
	{
		if (moduleLen < 0x30)
			return false;
		if (module[6] != 'R' || module[7] != 'M' || module[8] != 'T' || module[0xd] != 1)
			return false;
		return true;
	}

	void ParseRmt!(byte[] module, int moduleLen)
		throws
	{
		if (!ValidateRmt(module, moduleLen))
			throw "Invalid RMT file";
		int posShift;
		switch (module[9]) {
		case '4':
			posShift = 2;
			break;
		case '8':
			Channels = 2;
			posShift = 3;
			break;
		default:
			throw "Unsupported number of channels";
		}
		int perFrame = module[0xc];
		if (perFrame < 1 || perFrame > 4)
			throw "Unsupported player call rate";
		Type = ASAPModuleType.Rmt;
		ParseModule(module, moduleLen);
		int blockLen = GetWord(module, 4) + 1 - Music;
		int songLen = GetWord(module, 4) + 1 - GetWord(module, 0x14);
		if (posShift == 3 && (songLen & 4) != 0 && module[6 + blockLen - 4] == 0xfe)
			songLen += 4;
		songLen >>= posShift;
		if (songLen >= 0x100)
			throw "Song too long";
		bool[256] globalSeen = false;
		Songs = 0;
		for (int pos = 0; pos < songLen && Songs < MaxSongs; pos++) {
			if (!globalSeen[pos]) {
				SongPos[Songs] = pos;
				ParseRmtSong(module, globalSeen, songLen, posShift, pos);
			}
		}
		// must set Fastplay after song durations calculations, so they assume 312
		Fastplay = 312 / perFrame;
		Player = 0x600;
		if (Songs == 0)
			throw "No songs found";
#if !OPENCL
		byte[MaxTextLength] title;
		int titleLen;
		for (titleLen = 0; titleLen < MaxTextLength && 10 + blockLen + titleLen < moduleLen; titleLen++) {
			int c = module[10 + blockLen + titleLen];
			if (c == 0)
				break;
			// RMT only allows entering characters we consider valid, but let's check just in case
			title[titleLen] = IsValidChar(c) ? c : ' ';
		}
		Title = Encoding.UTF8.GetString(title, 0, titleLen);
#endif
	}

	void ParseTmcSong!(byte[] module, int pos)
	{
		int addrToOffset = GetWord(module, 2) - 6;
		int tempo = module[0x24] + 1;
		int frames = 0;
		int[8] patternOffset;
		int[8] blankRows;
		while (module[0x1a6 + 15 + pos] < 0x80) {
			for (int ch = 7; ch >= 0; ch--) {
				int pat = module[0x1a6 + 15 + pos - 2 * ch];
				patternOffset[ch] = module[0xa6 + pat] + (module[0x126 + pat] << 8) - addrToOffset;
				blankRows[ch] = 0;
			}
			for (int patternRows = 64; --patternRows >= 0; ) {
				for (int ch = 7; ch >= 0; ch--) {
					if (--blankRows[ch] >= 0)
						continue;
					for (;;) {
						int i = module[patternOffset[ch]++];
						if (i < 0x40) {
							patternOffset[ch]++;
							break;
						}
						if (i == 0x40) {
							i = module[patternOffset[ch]++];
							if ((i & 0x7f) == 0)
								patternRows = 0;
							else
								tempo = (i & 0x7f) + 1;
							if (i >= 0x80)
								patternOffset[ch]++;
							break;
						}
						if (i < 0x80) {
							i = module[patternOffset[ch]++] & 0x7f;
							if (i == 0)
								patternRows = 0;
							else
								tempo = i + 1;
							patternOffset[ch]++;
							break;
						}
						if (i < 0xc0)
							continue;
						blankRows[ch] = i - 0xbf;
						break;
					}
				}
				frames += tempo;
			}
			pos += 16;
		}
		if (module[0x1a6 + 14 + pos] < 0x80)
			Loops[Songs] = true;
		AddSong(frames);
	}

#if !OPENCL
	static int ParseTmcTitle(byte[]! title, int titleLen, byte[] module, int moduleOffset)
	{
		int lastOffset = moduleOffset + 29;
		while (module[lastOffset] == ' ') {
			if (--lastOffset < moduleOffset)
				return titleLen;
		}
		if (titleLen > 0) {
			title[titleLen++] = ' ';
			title[titleLen++] = '|';
			title[titleLen++] = ' ';
		}
		while (moduleOffset <= lastOffset) {
			int c = module[moduleOffset++] & 0x7f;
			switch (c) {
			case 't' - 96:
				c = '*';
				break;
			// Replace Polish letters with their English equivalents.
			// This is common practice when Polish letters are unavailable.
			case 'a' - 96:
			case 'c' - 96:
			case 'e' - 96:
			case 'l' - 96:
			case 'n' - 96:
			case 'o' - 96:
			case 's' - 96:
				c += 96;
				break;
			case 'x' - 96:
			case 'z' - 96:
				c = 'z';
				break;
			default:
				if (!IsValidChar(c))
					c = ' ';
				break;
			}
			title[titleLen++] = c;
		}
		return titleLen;
	}
#endif

	void ParseTmc!(byte[] module, int moduleLen)
		throws
	{
		if (moduleLen < 0x1d0)
			throw "Module too short";
		Type = ASAPModuleType.Tmc;
		ParseModule(module, moduleLen);
		Channels = 2;
		int i = 0;
		// find first instrument
		while (module[0x66 + i] == 0) {
			if (++i >= 64)
				throw "No instruments";
		}
		int lastPos = (module[0x66 + i] << 8) + module[0x26 + i] - GetWord(module, 2) - 0x1b0;
		if (0x1b5 + lastPos >= moduleLen)
			throw "Module too short";
		// skip trailing jumps
		do {
			if (lastPos <= 0)
				throw "No songs found";
			lastPos -= 16;
		} while (module[0x1b5 + lastPos] >= 0x80);
		Songs = 0;
		ParseTmcSong(module, 0);
		for (i = 0; i < lastPos && Songs < MaxSongs; i += 16)
			if (module[0x1b5 + i] >= 0x80)
				ParseTmcSong(module, i + 16);
		// must set fastplay after song durations calculations, so they assume 312
		i = module[0x25];
		if (i < 1 || i > 4)
			throw "Unsupported player call rate";
		Fastplay = 312 / i;
#if !OPENCL
		byte[MaxTextLength] title;
		int titleLen = ParseTmcTitle(title, 0, module, 6);
		Title = Encoding.UTF8.GetString(title, 0, titleLen);
#endif
	}

	void ParseTm2Song!(byte[] module, int pos)
	{
		int addrToOffset = GetWord(module, 2) - 6;
		int tempo = module[0x24] + 1;
		int playerCalls = 0;
		int[8] patternOffset;
		int[8] blankRows;
		for (;;) {
			int patternRows = module[0x386 + 16 + pos];
			if (patternRows == 0)
				break;
			if (patternRows >= 0x80) {
				Loops[Songs] = true;
				break;
			}
			for (int ch = 7; ch >= 0; ch--) {
				int pat = module[0x386 + 15 + pos - 2 * ch];
				patternOffset[ch] = module[0x106 + pat] + (module[0x206 + pat] << 8) - addrToOffset;
				blankRows[ch] = 0;
			}
			while (--patternRows >= 0) {
				for (int ch = 7; ch >= 0; ch--) {
					if (--blankRows[ch] >= 0)
						continue;
					for (;;) {
						int i = module[patternOffset[ch]++];
						if (i == 0) {
							patternOffset[ch]++;
							break;
						}
						if (i < 0x40) {
							if (module[patternOffset[ch]++] >= 0x80)
								patternOffset[ch]++;
							break;
						}
						if (i < 0x80) {
							patternOffset[ch]++;
							break;
						}
						if (i == 0x80) {
							blankRows[ch] = module[patternOffset[ch]++];
							break;
						}
						if (i < 0xc0)
							break;
						if (i < 0xd0) {
							tempo = i - 0xbf;
							continue;
						}
						if (i < 0xe0) {
							patternOffset[ch]++;
							break;
						}
						if (i < 0xf0) {
							patternOffset[ch] += 2;
							break;
						}
						if (i < 0xff) {
							blankRows[ch] = i - 0xf0;
							break;
						}
						blankRows[ch] = 64;
						break;
					}
				}
				playerCalls += tempo;
			}
			pos += 17;
		}
		AddSong(playerCalls);
	}

	void ParseTm2!(byte[] module, int moduleLen)
		throws
	{
		if (moduleLen < 0x3a4)
			throw "Module too short";
		Type = ASAPModuleType.Tm2;
		ParseModule(module, moduleLen);
		int i = module[0x25];
		if (i < 1 || i > 4)
			throw "Unsupported player call rate";
		Fastplay = 312 / i;
		Player = 0x800;
		if (module[0x1f] != 0)
			Channels = 2;
		int lastPos = 0xffff;
		for (i = 0; i < 0x80; i++) {
			int instrAddr = module[0x86 + i] + (module[0x306 + i] << 8);
			if (instrAddr != 0 && instrAddr < lastPos)
				lastPos = instrAddr;
		}
		for (i = 0; i < 0x100; i++) {
			int patternAddr = module[0x106 + i] + (module[0x206 + i] << 8);
			if (patternAddr != 0 && patternAddr < lastPos)
				lastPos = patternAddr;
		}
		lastPos -= GetWord(module, 2) + 0x380;
		if (0x386 + lastPos >= moduleLen)
			throw "Module too short";
		// skip trailing stop/jump commands
		int c;
		do {
			if (lastPos <= 0)
				throw "No songs found";
			lastPos -= 17;
			c = module[0x386 + 16 + lastPos];
		} while (c == 0 || c >= 0x80);
		Songs = 0;
		ParseTm2Song(module, 0);
		for (i = 0; i < lastPos && Songs < MaxSongs; i += 17) {
			c = module[0x386 + 16 + i];
			if (c == 0 || c >= 0x80)
				ParseTm2Song(module, i + 17);
		}
#if !OPENCL
		byte[MaxTextLength] title;
		int titleLen = ParseTmcTitle(title, 0, module, 0x27);
		titleLen = ParseTmcTitle(title, titleLen, module, 0x47);
		titleLen = ParseTmcTitle(title, titleLen, module, 0x67);
		Title = Encoding.UTF8.GetString(title, 0, titleLen);
#endif
	}

	static int AfterFF(byte[] module, int moduleLen, int currentOffset)
		throws
	{
		while (currentOffset < moduleLen) {
			if (module[currentOffset++] == 0xff)
				return currentOffset;
		}
		throw "Module too short";
	}

	static int GetFcTrackCommand(byte[] module, int[] trackPos, int n)
		=> module[3 + (n << 8) + trackPos[n]];

	static bool IsFcSongEnd(byte[] module, int[] trackPos)
	{
		// stops when one channel (or more) has STOP command or each channel has LOOP command
		bool allLoop = true;
		for (int n = 0; n < 3; n++) {
			if (trackPos[n] >= 0x100)
				return true;
			switch (GetFcTrackCommand(module, trackPos, n)) {
			case 0xfe: // STOP
				return true;
			case 0xff: // LOOP
				break;
			default:
				allLoop = false;
				break;
			}
		}
		return allLoop;
	}

	static bool ValidateFc(byte[] module, int moduleLen)
	{
		if (moduleLen < 0x383)
			return false;
		if (module[0] != 0x26 || module[1] != 0x23)
			return false;
		return true;
	}

	void ParseFc!(byte[] module, int moduleLen)
		throws
	{
		if (!ValidateFc(module, moduleLen))
			throw "Invalid FC file";
		Type = ASAPModuleType.Fc;

		Player = 0x400;
		Music = 0xa00;
		Songs = 0;
		HeaderLen = -1;

		int[0x40] patternOffsets;
		int currentOffset = 0x383;
		// patterns
		for (int i = 0; i < 0x40; i++) {
			patternOffsets[i] = currentOffset;
			currentOffset = AfterFF(module, moduleLen, currentOffset);
		}
		// envelopes
		for (int i = 0; i < 0x20; i++)
			currentOffset = AfterFF(module, moduleLen, currentOffset);

		for (int pos = 0; pos < 0x100 && Songs < MaxSongs; ) {
			int[3] trackPos;
			for (int n = 0; n < 3; n++)
				trackPos[n] = pos;
			int[3] patternDelay = 0;
			int[3] noteDuration = 0;
			int[3] patternPos = 0;
			int playerCalls = 0;
			Loops[Songs] = true;

			while (!IsFcSongEnd(module, trackPos)) {
				for (int n = 0; n < 3; n++) {
					if (GetFcTrackCommand(module, trackPos, n) == 0xff)
						continue;
					if (patternDelay[n]-- > 0)
						continue;
					while (trackPos[n] < 0x100) {
						int trackCmd = GetFcTrackCommand(module, trackPos, n);
						if (trackCmd < 0x40) {
							int patternCmd = module[patternOffsets[trackCmd] + patternPos[n]++];
							if (patternCmd < 0x40) {
								patternDelay[n] = noteDuration[n];
								break;
							}
							else if (patternCmd < 0x60)
								noteDuration[n] = patternCmd - 0x40;
							else if (patternCmd == 0xff) {
								patternDelay[n] = 0;
								noteDuration[n] = 0;
								patternPos[n] = 0;
								trackPos[n]++;
							}
						}
						else if (trackCmd == 0x40)
							trackPos[n] += 2;
						else if (trackCmd == 0xfe) {
							Loops[Songs] = false;
							break;
						}
						else if (trackCmd == 0xff)
							break;
						else
							trackPos[n]++;
					}
				}
				if (IsFcSongEnd(module, trackPos))
					break;
				playerCalls += module[2];
			}

			pos = -1;
			for (int n = 0; n < 3; n++) {
				int nxtrkpos = trackPos[n];
				if (patternPos[n] > 0)
					nxtrkpos++;
				if (pos < nxtrkpos)
					pos = nxtrkpos;
			}
			pos++;
			if (pos <= 0x100)
				AddSong(playerCalls);
		}
	}

#if !OPENCL
	static string() ParseText(byte[] module, int i, int argEnd)
	{
		int len = argEnd - i - 2;
		if (i < 0 || len < 0 || module[i] != '"' || module[argEnd - 1] != '"')
			return ""; // silently ignore malformed AUTHOR/NAME/DATE
		if (len == 3 && module[i + 1] == '<' && module[i + 2] == '?' && module[i + 3] == '>')
			return "";
		return Encoding.UTF8.GetString(module, i + 1, len);
	}
#endif

	static bool HasStringAt(byte[] module, int moduleIndex, string s)
	{
		foreach (int c in s)
			if (c != module[moduleIndex++])
				return false;
		return true;
	}

	static int ParseDec(byte[] module, int i, int argEnd, int minVal, int maxVal)
		throws
	{
		if (i < 0)
			throw "Missing number";
		int r = 0;
		while (i < argEnd) {
			int c = module[i++];
			if (c < '0' || c > '9')
				throw "Invalid number";
			r = r * 10 + c - '0';
			if (r > maxVal)
				throw "Number too big";
		}
		if (r < minVal)
			throw "Number too small";
		return r;
	}

	static int ParseHex(byte[] module, int i, int argEnd)
		throws
	{
		if (i < 0)
			throw "Missing number";
		int r = 0;
		while (i < argEnd) {
			int c = module[i++];
			if (r > 0xfff)
				throw "Number too big";
			r <<= 4;
			if (c >= '0' && c <= '9')
				r += c - '0';
			else if (c >= 'A' && c <= 'F')
				r += c - 'A' + 10;
			else if (c >= 'a' && c <= 'f')
				r += c - 'a' + 10;
			else
				throw "Invalid number";
		}
		return r;
	}

	/// Returns the number of milliseconds represented by the given string.
	public static int ParseDuration(
		/// Time in the `"mm:ss.xxx"` format.
		string s)
		throws
	{
		DurationParser() parser;
		return parser.Parse(s);
	}

	static bool ValidateSap(byte[] module, int moduleLen)
		=> moduleLen >= 30 && HasStringAt(module, 0, "SAP\r\n");

	void ParseSap!(byte[] module, int moduleLen)
		throws
	{
		if (!ValidateSap(module, moduleLen))
			throw "Invalid SAP file";
		Fastplay = -1;
		int type = 0;
		int moduleIndex = 5;
		int durationIndex = 0;
		while (module[moduleIndex] != 0xff) {
			// find where the tag ends
			int lineStart = moduleIndex;
			while (module[moduleIndex] > ' ') {
				if (++moduleIndex >= moduleLen)
					throw "Invalid SAP file";
			}
			int tagLen = moduleIndex - lineStart;

			// find where is the argument, if any
			int argStart = -1;
			int argEnd = -1;
			for (;;) {
				int c = module[moduleIndex];
				if (c > ' ') {
					CheckValidChar(c);
					if (argStart < 0)
						argStart = moduleIndex;
					argEnd = -1;
				}
				else {
					if (argEnd < 0)
						argEnd = moduleIndex;
					if (c == '\n')
						break;
				}
				if (++moduleIndex >= moduleLen)
					throw "Invalid SAP file";
			}
			if (++moduleIndex + 6 >= moduleLen)
				throw "Invalid SAP file";

			// handle tags, ignore unknown
			switch (Encoding.UTF8.GetString(module, lineStart, tagLen)) {
#if !OPENCL
			case "AUTHOR":
				Author = ParseText(module, argStart, argEnd);
				break;
			case "NAME":
				Title = ParseText(module, argStart, argEnd);
				break;
			case "DATE":
				Date = ParseText(module, argStart, argEnd);
				break;
			case "TIME":
				if (durationIndex >= MaxSongs)
					throw "Too many TIME tags";
				if (argStart < 0)
					throw "Missing TIME argument";
				if (argEnd - argStart > 5 && HasStringAt(module, argEnd - 5, " LOOP")) {
					Loops[durationIndex] = true;
					argEnd -= 5;
				}
				{
					string() arg = Encoding.UTF8.GetString(module, argStart, argEnd - argStart);
					Durations[durationIndex++] = ParseDuration(arg);
				}
				break;
#endif
			case "SONGS":
				Songs = ParseDec(module, argStart, argEnd, 1, MaxSongs);
				break;
			case "DEFSONG":
				DefaultSong = ParseDec(module, argStart, argEnd, 0, MaxSongs - 1);
				break;
			case "TYPE":
				if (argStart < 0)
					throw "Missing TYPE argument";
				type = module[argStart];
				break;
			case "FASTPLAY":
				Fastplay = ParseDec(module, argStart, argEnd, 1, 32767);
				break;
			case "MUSIC":
				Music = ParseHex(module, argStart, argEnd);
				break;
			case "INIT":
				Init = ParseHex(module, argStart, argEnd);
				break;
			case "PLAYER":
				Player = ParseHex(module, argStart, argEnd);
				break;
			case "COVOX":
				CovoxAddr = ParseHex(module, argStart, argEnd);
				if (CovoxAddr != 0xd600)
					throw "COVOX should be D600";
				Channels = 2;
				break;
			case "STEREO":
				Channels = 2;
				break;
			case "NTSC":
				Ntsc = true;
				break;
			default:
				break;
			}
		}

		if (DefaultSong >= Songs)
			throw "DEFSONG too big";
		switch (type) {
		case 'B':
			if (Player < 0)
				throw "Missing PLAYER tag";
			if (Init < 0)
				throw "Missing INIT tag";
			Type = ASAPModuleType.SapB;
			break;
		case 'C':
			if (Player < 0)
				throw "Missing PLAYER tag";
			if (Music < 0)
				throw "Missing MUSIC tag";
			Type = ASAPModuleType.SapC;
			break;
		case 'D':
			if (Init < 0)
				throw "Missing INIT tag";
			Type = ASAPModuleType.SapD;
			break;
		case 'S':
			if (Init < 0)
				throw "Missing INIT tag";
			Type = ASAPModuleType.SapS;
			if (Fastplay < 0)
				Fastplay = 78;
			break;
		default:
			throw "Unsupported TYPE";
		}
		if (Fastplay < 0)
			Fastplay = Ntsc ? 262 : 312;
		if (module[moduleIndex + 1] != 0xff)
			throw "Invalid binary header";
		HeaderLen = moduleIndex;
	}

	internal static int PackExt(string ext)
		=> ext.Length == 2 && ext[0] <= 'z' && ext[1] <= 'z' ? ext[0] | ext[1] << 8 | 0x202020
		 : ext.Length == 3 && ext[0] <= 'z' && ext[1] <= 'z' && ext[2] <= 'z' ? ext[0] | ext[1] << 8 | ext[2] << 16 | 0x202020
		 : 0;

	internal static int GetPackedExt(string filename)
	{
		int ext = 0;
		for (int i = filename.Length; --i > 0; ) {
			int c = filename[i];
			if (c <= ' ' || c > 'z')
				return 0;
			if (c == '.')
				return ext | 0x202020;
			ext = (ext << 8) + c;
		}
		return 0;
	}

	static bool IsOurPackedExt(int ext)
	{
		switch (ext) {
		case PackExt("SAP"):
#if !ASAP_ONLY_SAP
		case PackExt("CMC"):
		case PackExt("CM3"):
		case PackExt("CMR"):
		case PackExt("CMS"):
		case PackExt("DMC"):
		case PackExt("DLT"):
		case PackExt("MPT"):
		case PackExt("MPD"):
		case PackExt("RMT"):
		case PackExt("TMC"):
		case PackExt("TM8"):
		case PackExt("TM2"):
		case PackExt("FC"):
#if EXPERIMENTAL_XEX
		case PackExt("XEX"):
#endif
#endif
			return true;
		default:
			return false;
		}
	}

	/// Checks whether the filename represents a module type supported by ASAP.
	/// Returns `true` if the filename is supported by ASAP.
	public static bool IsOurFile(
		/// Filename to check the extension of.
		string filename)
		=> IsOurPackedExt(GetPackedExt(filename));

	/// Checks whether the filename extension represents a module type supported by ASAP.
	/// Returns `true` if the filename extension is supported by ASAP.
	public static bool IsOurExt(
		/// Filename extension without the leading dot.
		string ext)
		=> IsOurPackedExt(PackExt(ext));

	static int GuessPackedExt(byte[] module, int moduleLen)
		throws
	{
		if (ValidateSap(module, moduleLen))
			return PackExt("SAP");
		if (ValidateFc(module, moduleLen))
			return PackExt("FC");
		if (ValidateRmt(module, moduleLen))
			return PackExt("RMT");
		throw "Unknown format";
	}

	/// Loads file information.
	public void Load!(
		/// Filename, used to determine the format.
		string filename,
		/// Contents of the file.
		byte[] module,
		/// Length of the file.
		int moduleLen)
		throws
	{
		int ext;
		if (filename != null) {
			int len = filename.Length;
			int basename = 0;
			ext = -1;
			for (int i = len; --i >= 0; ) {
				int c = filename[i];
				if (c == '/' || c == '\\') {
					basename = i + 1;
					break;
				}
				if (c == '.')
					ext = i;
			}
			if (ext < 0)
				throw "Filename has no extension";
			ext -= basename;
			if (ext > MaxTextLength)
				ext = MaxTextLength;
#if !OPENCL
			Filename = filename.Substring(basename, ext);
#endif
			ext = GetPackedExt(filename);
		}
		else {
#if !OPENCL
			Filename = "";
#endif
			ext = GuessPackedExt(module, moduleLen);
		}

#if !OPENCL
		Author = "";
		Title = "";
		Date = "";
#endif
		Channels = 1;
		Songs = 1;
		DefaultSong = 0;
		for (int i = 0; i < MaxSongs; i++) {
			Durations[i] = -1;
			Loops[i] = false;
		}
		Ntsc = false;
		Fastplay = 312;
		Music = -1;
		Init = -1;
		Player = -1;
		CovoxAddr = -1;
		HeaderLen = 0;
		switch (ext) {
		case PackExt("SAP"):
			ParseSap(module, moduleLen);
			return;
#if !ASAP_ONLY_SAP
		case PackExt("CMC"):
			ParseCmc(module, moduleLen, ASAPModuleType.Cmc);
			return;
		case PackExt("CM3"):
			ParseCmc(module, moduleLen, ASAPModuleType.Cm3);
			return;
		case PackExt("CMR"):
			ParseCmc(module, moduleLen, ASAPModuleType.Cmr);
			return;
		case PackExt("CMS"):
			Channels = 2;
			ParseCmc(module, moduleLen, ASAPModuleType.Cms);
			return;
		case PackExt("DMC"):
			Fastplay = 156;
			ParseCmc(module, moduleLen, ASAPModuleType.Cmc);
			return;
		case PackExt("DLT"):
			ParseDlt(module, moduleLen);
			return;
		case PackExt("MPT"):
			ParseMpt(module, moduleLen);
			return;
		case PackExt("MPD"):
			Fastplay = 156;
			ParseMpt(module, moduleLen);
			return;
		case PackExt("RMT"):
			ParseRmt(module, moduleLen);
			return;
		case PackExt("TMC"):
		case PackExt("TM8"):
			ParseTmc(module, moduleLen);
			return;
		case PackExt("TM2"):
			ParseTm2(module, moduleLen);
			return;
		case PackExt("FC"):
			ParseFc(module, moduleLen);
			return;
#if EXPERIMENTAL_XEX
		case PackExt("XEX"):
			if (moduleLen < 7 || module[0] != 0xff || module[1] != 0xff)
				throw "Missing 0xff,0xff header";
			Type = ASAPModuleType.Xex;
			return;
#endif
#endif
		default:
			throw "Unknown filename extension";
		}
	}

#if !OPENCL

	static void CheckValidText(string s)
		throws
	{
		if (s.Length > MaxTextLength)
			throw "Text too long";
		foreach (int c in s)
			CheckValidChar(c);
	}

	/// Returns author's name.
	/// A nickname may be included in parentheses after the real name.
	/// Multiple authors are separated with `" & "`.
	/// An empty string means the author is unknown.
	public string GetAuthor() => Author;

	/// Sets author's name.
	/// A nickname may be included in parentheses after the real name.
	/// Multiple authors are separated with `" & "`.
	/// An empty string means the author is unknown.
	public void SetAuthor!(
		/// New author's name for the current music.
		string value)
		throws
	{
		CheckValidText(value);
		Author = value;
	}

	/// Returns music title.
	/// An empty string means the title is unknown.
	public string GetTitle() => Title;

	/// Sets music title.
	/// An empty string means the title is unknown.
	public void SetTitle!(
		/// New title for the current music.
		string value)
		throws
	{
		CheckValidText(value);
		Title = value;
	}

	/// Returns music title or filename.
	/// If title is unknown returns filename without the path or extension.
	public string GetTitleOrFilename() => Title.Length > 0 ? Title : Filename;

	/// Returns music creation date.
	/// Some of the possible formats are:
	/// * YYYY
	/// * MM/YYYY
	/// * DD/MM/YYYY
	/// * YYYY-YYYY
	///
	/// An empty string means the date is unknown.
	public string GetDate() => Date;

	/// Sets music creation date.
	/// Some of the possible formats are:
	/// * YYYY
	/// * MM/YYYY
	/// * DD/MM/YYYY
	/// * YYYY-YYYY
	///
	/// An empty string means the date is unknown.
	public void SetDate!(
		/// New music creation date.
		string value)
		throws
	{
		CheckValidText(value);
		Date = value;
	}

	int CheckDate()
	{
		int n = Date.Length;
		switch (n) {
		case 4: // YYYY
		case 7: // MM/YYYY
		case 10: // DD/MM/YYYY
			break;
		default:
			return -1;
		}
		for (int i = 0; i < n; i++) {
			int c = Date[i];
			if (i == n - 5 || i == n - 8) {
				if (c != '/')
					return -1;
			}
			else if (c < '0' || c > '9')
				return -1;
		}
		return n;
	}

	int GetTwoDateDigits(int i) => (Date[i] - '0') * 10 + Date[i + 1] - '0';

	/// Returns music creation year.
	/// -1 means the year is unknown.
	public int GetYear()
	{
		int n = CheckDate();
		if (n < 0)
			return -1;
		return GetTwoDateDigits(n - 4) * 100 + GetTwoDateDigits(n - 2);
	}

	/// Returns music creation month (1-12).
	/// -1 means the month is unknown.
	public int GetMonth()
	{
		int n = CheckDate();
		if (n < 7)
			return -1;
		return GetTwoDateDigits(n - 7);
	}

	/// Returns day of month of the music creation date.
	/// -1 means the day is unknown.
	public int GetDayOfMonth()
	{
		int n = CheckDate();
		if (n != 10)
			return -1;
		return GetTwoDateDigits(0);
	}

#endif

	/// Returns 1 for mono or 2 for stereo.
	public int GetChannels() => Channels;

	/// Returns number of songs in the file.
	public int GetSongs() => Songs;

	/// Returns 0-based index of the "main" song.
	/// The specified song should be played by default.
	public int GetDefaultSong() => DefaultSong;

	/// Sets the 0-based index of the "main" song.
	public void SetDefaultSong!(
		/// New default song.
		int song)
		throws
	{
		if (song < 0 || song >= Songs)
			throw "Song out of range";
		DefaultSong = song;
	}

	/// Returns length of the specified song.
	/// The length is specified in milliseconds. -1 means the length is indeterminate.
	public int GetDuration(
		/// Song to get length of, 0-based.
		int song)
		=> Durations[song];

	/// Sets length of the specified song.
	/// The length is specified in milliseconds. -1 means the length is indeterminate.
	public void SetDuration!(
		/// Song to set length of, 0-based.
		int song,
		/// New length in milliseconds.
		int duration)
		throws
	{
		if (song < 0 || song >= Songs)
			throw "Song out of range";
		Durations[song] = duration;
	}

	/// Returns information whether the specified song loops.
	/// Returns:
	/// * `true` if the song loops
	/// * `false` if the song stops
	public bool GetLoop(
		/// Song to check for looping, 0-based.
		int song)
		=> Loops[song];

	/// Sets information whether the specified song loops.
	/// Use:
	/// * `true` if the song loops
	/// * `false` if the song stops
	public void SetLoop!(
		/// Song to set as looping, 0-based.
		int song,
		/// `true` if the song loops.
		bool loop)
		throws
	{
		if (song < 0 || song >= Songs)
			throw "Song out of range";
		Loops[song] = loop;
	}

	/// Returns `true` for an NTSC song and `false` for a PAL song.
	public bool IsNtsc() => Ntsc;

	/// Returns `true` if NTSC can be set or removed.
	public bool CanSetNtsc() => Type == ASAPModuleType.SapB && Fastplay == (Ntsc ? 262 : 312);

	/// Marks a SAP file as NTSC or PAL.
	public void SetNtsc!(
		/// `true` for NTSC, `false` for PAL.
		bool ntsc)
	{
		Ntsc = ntsc;
		Fastplay = ntsc ? 262 : 312;
		for (int song = 0; song < Songs; song++) {
			long duration = Durations[song];
			if (duration > 0) {
				// 78 is the GCD
				Durations[song] = ntsc
					? duration * (1773447 * 262 / 78) / (3579545 * 312 / 2 / 78)
					: duration * (3579545 * 312 / 2 / 78) / (1773447 * 262 / 78);
			}
		}
	}

	/// Returns the letter argument for the TYPE SAP tag.
	/// Returns zero for non-SAP files.
	public int GetTypeLetter()
	{
		switch (Type) {
		case ASAPModuleType.SapB: return 'B';
		case ASAPModuleType.SapC: return 'C';
		case ASAPModuleType.SapD: return 'D';
		case ASAPModuleType.SapS: return 'S';
		default: return 0;
		}
	}

	/// Returns player routine rate in Atari scanlines.
	public int GetPlayerRateScanlines() => Fastplay;

	/// Returns approximate player routine rate in Hz.
	public int GetPlayerRateHz()
	{
		int scanlineClock = Ntsc ? 1789772 / 114 : 1773447 / 114;
		return (scanlineClock + (Fastplay >> 1)) / Fastplay;
	}

	/// Returns the address of the module.
	/// Returns -1 if unknown.
	public int GetMusicAddress() => Music;

	/// Causes music to be relocated.
	/// Use only with `ASAPWriter.Write`.
	public void SetMusicAddress!(
		/// New music address.
		int address)
		throws
	{
		if (address < 0 || address >= 0xffff)
			throw "Invalid music address";
		Music = address;
	}

	/// Returns the address of the player initialization routine.
	/// Returns -1 if no initialization routine.
	public int GetInitAddress() => Init;

	/// Returns the address of the player routine.
	public int GetPlayerAddress() => Player;

	/// Returns the address of the COVOX chip.
	/// Returns -1 if no COVOX enabled.
	public int GetCovoxAddress() => CovoxAddr;

	/// Returns the length of the SAP header in bytes.
	public int GetSapHeaderLength() => HeaderLen;

	/// Returns the offset of instrument names for RMT module.
	/// Returns -1 if not an RMT module or RMT module without instrument names.
	public int GetInstrumentNamesOffset(
		/// Content of the RMT file.
		byte[] module,
		/// Length of the RMT file.
		int moduleLen)
	{
		if (Type != ASAPModuleType.Rmt)
			return -1;
		for (int offset = GetWord(module, 4) - GetWord(module, 2) + 12; offset < moduleLen; offset++) {
			if (module[offset - 1] == 0)
				return offset;
		}
		return -1;
	}

#if !ASAP_ONLY_SAP

	/// Returns human-readable description of the filename extension.
	public static string GetExtDescription(
		/// Filename extension without the leading dot.
		string ext)
		throws
	{
		switch (PackExt(ext)) {
		case PackExt("SAP"): return "Slight Atari Player";
		case PackExt("CMC"): return "Chaos Music Composer";
		case PackExt("CM3"): return "CMC \"3/4\"";
		case PackExt("CMR"): return "CMC \"Rzog\"";
		case PackExt("CMS"): return "Stereo Double CMC";
		case PackExt("DMC"): return "CMC DoublePlay";
		case PackExt("DLT"): return "Delta Music Composer";
		case PackExt("MPT"): return "Music ProTracker";
		case PackExt("MPD"): return "MPT DoublePlay";
		case PackExt("RMT"): return "Raster Music Tracker";
		case PackExt("TMC"):
		case PackExt("TM8"): return "Theta Music Composer 1.x";
		case PackExt("TM2"): return "Theta Music Composer 2.x";
		case PackExt("FC"): return "Future Composer";
		case PackExt("XEX"): return "Atari 8-bit executable";
		default: throw "Unknown extension";
		}
	}

	const int RmtInit = 0xc80;

	internal int GetRmtSapOffset(byte[] module, int moduleLen)
	{
		if (Player != 0x3403)
			return -1;
		int offset = HeaderLen + GetWord(module, HeaderLen + 4) - GetWord(module, HeaderLen + 2) + 7;
		if (offset + 6 >= moduleLen || module[offset + 4] != 'R' || module[offset + 5] != 'M' || module[offset + 6] != 'T')
			return -1;
		return offset;
	}

	internal ASAPModuleType GetOriginalModuleType(
		byte[] module,
		int moduleLen)
	{
		switch (Type) {
		case ASAPModuleType.SapB:
			if ((Init == 0x3fb || Init == 0x3f9) && Player == 0x503)
				return ASAPModuleType.Dlt;
			if (((Init == 0x4f3 || Init == 0x4ef) && Player == 0x503) || (Init == 0xf4f3 && Player == 0xf503))
				return ASAPModuleType.Mpt;
			if (Init == RmtInit || GetRmtSapOffset(module, moduleLen) > 0)
				return ASAPModuleType.Rmt;
			if ((Init == 0x4f5 || Init == 0xf4f5 || Init == 0x4f2)
			 || ((Init == 0x4e7 || Init == 0xf4e7 || Init == 0x4e4) && Fastplay == 156)
			 || ((Init == 0x4e5 || Init == 0xf4e5 || Init == 0x4e2) && (Fastplay == 104 || Fastplay == 78)))
				return ASAPModuleType.Tmc;
			if ((Init == 0x1080 && Player == 0x503) || (Init == 0x1380 && Player == 0x803))
				return ASAPModuleType.Tm2;
			if (Init == 0x400 && Player == 0x403)
				return ASAPModuleType.Fc;
			return Type;
		case ASAPModuleType.SapC:
			if ((Player == 0x500 || Player == 0xf500) && moduleLen >= 1024) {
				if (Channels > 1)
					return ASAPModuleType.Cms;
				if (module[moduleLen - 170] == 0x1e)
					return ASAPModuleType.Cmr;
				if (module[moduleLen - 909] == 0x30)
					return ASAPModuleType.Cm3;
				return ASAPModuleType.Cmc;
			}
			return Type;
		default:
			return Type;
		}
	}

	/// Returns the extension of the original module format.
	/// For native modules it simply returns their extension.
	/// For the SAP format it attempts to detect the original module format.
	public string GetOriginalModuleExt(
		/// Contents of the file.
		byte[] module,
		/// Length of the file.
		int moduleLen)
	{
		switch (GetOriginalModuleType(module, moduleLen)) {
		case ASAPModuleType.Cmc:
			return Fastplay == 156 ? "dmc" : "cmc";
		case ASAPModuleType.Cm3:
			return "cm3";
		case ASAPModuleType.Cmr:
			return "cmr";
		case ASAPModuleType.Cms:
			return "cms";
		case ASAPModuleType.Dlt:
			return "dlt";
		case ASAPModuleType.Mpt:
			return Fastplay == 156 ? "mpd" : "mpt";
		case ASAPModuleType.Rmt:
			return "rmt";
		case ASAPModuleType.Tmc:
			return "tmc";
		case ASAPModuleType.Tm2:
			return "tm2";
		case ASAPModuleType.Fc:
			return "fc";
		default:
			return null;
		}
	}

#endif
}
